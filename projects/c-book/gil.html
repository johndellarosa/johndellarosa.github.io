<!DOCTYPE html>
<html lang="en-US">
    <head>

        <meta charset="UTF-8">
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2C44LTKBE1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2C44LTKBE1');
</script>
        <!-- <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> -->
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
            <title>Global Interpreter Lock</title>
    
        <!-- Meta tags -->
        
        <meta name="keywords" content="GIL, Global Interpreter Lock, Python, C API, ctypes">
        <meta name="author" content="John Della Rosa" >
        <meta name="description" content="Introduction to the Global Interpreter Lock in Python and how to release it in C extensions">
        
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
        <link rel="apple-touch-icon" sizes="180x180" href="https://johndellarosa.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://johndellarosa.github.io/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://johndellarosa.github.io/favicon-16x16.png">
        <link rel="manifest" href="https://johndellarosa.github.io/site.webmanifest">
        <link rel="canonical" href="https://johndellarosa.github.io/projects/c-book/compiling"/>    
        <link rel="stylesheet" href="https://johndellarosa.github.io/style.css"> 
<!-- 
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
      

        <script src="../../math.js" type="text/javascript"></script> -->

    </head>
    <body>
        <div class="navbar">
            <b style="margin-right:10px">John Della Rosa</b>| 
            <a href="https://johndellarosa.github.io/">Home</a>|
            <a href="https://johndellarosa.github.io/resume">Resume</a>|
            <a href="https://johndellarosa.github.io/biography">About</a>|
            <a href="https://johndellarosa.github.io/projects">Projects</a>|
            <a href="https://johndellarosa.github.io/miscellaneous">Misc</a>|
            <a href="https://www.linkedin.com/in/johndellarosa/" target="_blank">Linkedin</a>|
            <a href="https://github.com/johndellarosa" target="_blank">Github</a>|
            <a href="https://play.google.com/store/apps/developer?id=JohnDellaRosa" target="_blank">Google Play</a>|
            <a href="https://apps.apple.com/us/developer/john-della-rosa/id1684177615" target="_blank">Apple Store</a>
        
        </div>
        <h2><a href= "table-of-contents.html">C in Python Textbook (Work in Progress)</a></h2>

<h3>by John Della Rosa</h3>
        <div id="text-contents" style="width:90%; margin:auto">
            <div id="Introduction">
                <h1>Global Interpreter Lock</h1>
                <h2>Introduction</h2>
                
                <h3>Recommended Prerequesites</h3>
                <ol>
                    <li><a href="./argtypes-restype.html">argtypes and restypes</a></li>
                    <li><a href="./c-api.html"> C-API</a></li>
                    <li><a href="./sampling-continuous.html">Sampling</a></li>
                    <li><a href="./multivariate-intro">Introduction to Multivariate Distributions</a></li>
               
                </ol>

                <h3>Recommended Software</h3>
               
                <h3>High Level Explanation</h3>

                <p>The Global Interpreter Lock (GIL) is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This means that even in a multi-threaded program, only one thread can execute Python code at a time. The GIL is necessary because CPython's memory management is not thread-safe.</p>

                <h3>Why is the GIL a Problem?</h3>

                For IO-bound threads, the GIL is released when the thread is waiting for IO operations to complete, allowing other threads to run. However, for CPU-bound threads, the GIL can become a bottleneck, as it prevents true parallel execution of Python code on multi-core processors.
                
                When you write a C function that is called from Python, you can release the GIL while performing long-running operations. This allows other threads to run while your C function is executing, improving performance in multi-threaded applications. 
                If you do not release the GIL, this can block even IO-bound threads.


                <h2>Python C API</h2>

                In the C-API, you can release the GIL using the <code>Py_BEGIN_ALLOW_THREADS</code> and <code>Py_END_ALLOW_THREADS</code> macros. These macros save the current thread state and release the GIL, allowing other threads to run. When the operation is complete, the GIL is reacquired, and the thread state is restored.

                <pre><code>
                    #include <Python.h>

                    // A long-running C function
                    static PyObject* long_running_function(PyObject* self, PyObject* args) {
                        // Release the GIL
                        Py_BEGIN_ALLOW_THREADS

                        // Perform long-running operation here
                        for (long i = 0; i &lt; 1e9; i++);

                        // Reacquire the GIL
                        Py_END_ALLOW_THREADS

                        Py_RETURN_NONE;
                    }

                    static PyMethodDef MyMethods[] = {
                        {"long_running_function", long_running_function, METH_VARARGS, "A long-running function."},
                        {NULL, NULL, 0, NULL}
                    };

                    static struct PyModuleDef mymodule = {
                        PyModuleDef_HEAD_INIT, // Always have this macro
                        "mymodule", // name of module
                        NULL, // module documentation, may be NULL
                        -1, // size of per-interpreter state of the module, or -1 if the module keeps state in global variables.
                        MyMethods // the PyMethodDef array defining methods of the module
                    };

                    PyMODINIT_FUNC PyInit_mymodule(void) {
                        return PyModule_Create(&mymodule);
                    }


                <h2>ctypes</h2>
                
                When using ctypes, the GIL is automatically released when calling C functions that do not interact with Python objects. This means that if you call a long-running C function from Python using ctypes, the GIL will be released during the execution of that function, allowing other Python threads to run concurrently. 
                Each foreign function call is wrapped in Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS macros, which automatically save and restore the GIL around the call. This is particularly useful for long-running C functions that do not need to interact with Python objects.

                
                <h3>Calling Python's C-API from ctypes</h3>

                If you need to call CPython API functions via ctypes.pythonapi, do so through PyDLL, which keeps the GIL held while calling the function.

                


                <h2>See Also</h2>
                <ol>
                    <li><a href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock">Glossary Entry</a></li>

                </ol>
                
                </div>



             




        </div>

</body>
</html>