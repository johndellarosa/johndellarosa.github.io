<!DOCTYPE html>
<html lang="en-US">
    <head>

        <meta charset="UTF-8">
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2C44LTKBE1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2C44LTKBE1');
</script>
        <!-- <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> -->
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
            <title>Compilation</title>
    
        <!-- Meta tags -->
        
        <meta name="keywords" content="Copula, Probability Integral Transform">
        <meta name="author" content="John Della Rosa" >
        <meta name="description" content="Introduction to distribution distance metrics">
        
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
        <link rel="apple-touch-icon" sizes="180x180" href="https://johndellarosa.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://johndellarosa.github.io/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://johndellarosa.github.io/favicon-16x16.png">
        <link rel="manifest" href="https://johndellarosa.github.io/site.webmanifest">
        <link rel="canonical" href="https://johndellarosa.github.io/projects/c-book/compiling"/>    
        <link rel="stylesheet" href="https://johndellarosa.github.io/style.css"> 
<!-- 
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
      

        <script src="../../math.js" type="text/javascript"></script> -->

    </head>
    <body>
        <div class="navbar">
            <b style="margin-right:10px">John Della Rosa</b>| 
            <a href="https://johndellarosa.github.io/">Home</a>|
            <a href="https://johndellarosa.github.io/resume">Resume</a>|
            <a href="https://johndellarosa.github.io/biography">About</a>|
            <a href="https://johndellarosa.github.io/projects">Projects</a>|
            <a href="https://johndellarosa.github.io/miscellaneous">Misc</a>|
            <a href="https://www.linkedin.com/in/johndellarosa/" target="_blank">Linkedin</a>|
            <a href="https://github.com/johndellarosa" target="_blank">Github</a>|
            <a href="https://play.google.com/store/apps/developer?id=JohnDellaRosa" target="_blank">Google Play</a>|
            <a href="https://apps.apple.com/us/developer/john-della-rosa/id1684177615" target="_blank">Apple Store</a>
        
        </div>
        <h2><a href= "table-of-contents.html">C in Python Textbook (Work in Progress)</a></h2>

<h3>by John Della Rosa</h3>
        <div id="text-contents" style="width:90%; margin:auto">
            <div id="Introduction">
                <h1>Global Interpreter Lock</h1>
                <h2>Introduction</h2>
                
                <h3>Recommended Prerequesites</h3>
                <ol>
                    <li><a href="https://johndellarosa.github.io/projects/biophysics-book/probability">Probability</a></li>
                    <li><a href="./probability-2.html">Probability II</a></li>
                    <li><a href="./sampling-continuous.html">Sampling</a></li>
                    <li><a href="./multivariate-intro">Introduction to Multivariate Distributions</a></li>
               
                </ol>

                <h3>Recommended Software</h3>
               
                An alternative to ctypes is the <a href="https://docs.python.org/3/c-api/index.html">Python C API</a>, which allows you to write C extensions that can be imported directly into Python. This is more complex but offers better performance and integration with Python's memory management.

                <h3>Anatomy of a C Extension</h3>
                

                A C extension in Python is a shared library that can be loaded by the Python interpreter. It typically includes:
                <ul>
                    <li>Header files that define the functions and types used in the extension.</li>
                    <li>Source files that implement the functions.</li>
                    <li>A setup script (usually named setup.py) that uses setuptools to build the extension.</li>
                    <li>A module definition file (usually named module.c) that defines the methods and initialization function for the extension.</li>
                </ul>
                
                <h3>Basic Example</h3>

                The first thing that we will do is create a C file using the Python header.

                <pre><code>

                #include &lt;Python.h&gt;

                // 1. C function exposed to Python
                static PyObject* helloworld(PyObject *self, PyObject *args) {
                    const char *name;
                    // 2. Parse Python arguments: expect a single string
                    if (!PyArg_ParseTuple(args, "s", &name)) {
                        return NULL; // Error in parsing arguments

                    }
                    // 3. C code: print greeting
                    printf("Hello, %s!\n", name);
                    // 4. Return None to Python
                    Py_RETURN_NONE;
                }

                // 5. Method Table: array lists functions exported to Python: name, C wrapper, calling convention, and docstring.
                static PyMethodDef Methods[] = {
                    {"hello", helloworld, METH_VARARGS, "Greet someone."},
                    {NULL, NULL, 0, NULL}
                };

                // 6. Module definition

                static struct PyModuleDef moduledef = {
                    PyModuleDef_HEAD_INIT,
                    "intro", // module name in python
                    "Basic API examples", // module docstring
                    -1, // no per-interpreter state
                    Methods
                };

                // 7. Module init function
                PyMODINIT_FUNC PyInit_intro(void) {
                    return PyModule_Create(&moduledef);
                }

                </code></pre>


                <pre><code>
                    from setuptools import setup, Extension

                    ext = Extension(
                        'intro',
                        sources=['hello.c'],
                    )

                    setup(
                        name='intro',
                        version='0.1',
                        ext_modules=[ext],
                    )


                </code></pre>


                To compile this C extension, you would typically run the following command in the terminal:
                <pre><code>
                    python setup.py build_ext --inplace
                </code></pre>

                This command uses setuptools to build the C extension in place, meaning it will create a shared library file (e.g., intro.so on Linux or intro.pyd on Windows) in the current directory.

                <pre><code>
                    import intro

                    # Call the C extension function
                    intro.hello("World") # prints "Hello World!"
                </code></pre>

                <h2>In Depth</h2>

                Taking a step back, let's look at each component of the C extension in more detail.



                <h3>PyMethodDef</h3>

                PyMethodDef is a structure that defines a Python module, class, instance, or static method. It contains the name of the method, a pointer to the C function that implements it, the calling convention (e.g., METH_VARARGS), and a docstring. You place these within NULL-terminated arrays for either 1. module method tables or 2. tp_methods table for bound instance/class/static methods.

                <pre><code>
                    typedef struct PyMethodDef {
                    const char  *ml_name;   /* Python-level name */
                    PyCFunction  ml_meth;   /* C function pointer (type depends on flags) */
                    int          ml_flags;  /* calling-convention + binding bitmask (flags) */
                    const char  *ml_doc;    /* __doc__ (UTF-8), or NULL */
                } PyMethodDef;

                </code></pre>

                <h4>ml_name</h4>

                The <code>ml_name</code> field is the name of the method as it will be called from Python. It should match the name used in the Python code. 

                <h4>ml_meth</h4>

                ml_meth is a pointer to the C function that implements the method. 
                

                The pointer's actual type depends on ml_flags and should be consistent with the calling convention specified in ml_flags. For example, if ml_flags is METH_VARARGS, ml_meth should be a PyCFunction that takes a PyObject* self and a PyObject* args.

                <h5>Example signature</h5>
                
                <pre><code>
                    PyObject *func(PyObject *self, PyObject *args);
                </code></pre>

                <h4>ml_flags</h4>

                The <code>ml_flags</code> field specifies the calling convention and binding flags for the method. Common flags include:
                <ul>
                    <li><code>METH_VARARGS</code>: The function takes a variable number of positional arguments. Example: <code>PyObject *func(PyObject *self, PyObject *args);</code></li>
                    <li><code>METH_KEYWORDS</code>: The function can accept keyword arguments. This can only be used in certain combinations with other flags, such as METH_VARARGS. Example: <code>PyObject *func(PyObject *self, PyObject *args, PyObject *kwargs);</code></li>
                    <li><code>METH_NOARGS</code>: The function does not take any arguments. CPython will pass NULL as the second parameter. Example: <code>PyObject *func(PyObject *self, PyObject *Py_UNUSED(ignored));</code></li>
                    <li><code>METH_O</code>: This function takes exactly one position arg. Example: <code>PyObject *func(PyObject *self, PyObject *arg);</code></li>


                </ul>

                Do not mix <code>METH_NOARGS</code> or <code>METHO_O</code> with other flags.

                <h5>FASTCALL & vectorcall</h5>

                With FASTCALL, positional arguments arrive as a C array rather than a tuple:

                <pre><code>
                    // METH_FASTCALL (positional-only)
                    PyObject *func(PyObject *self, PyObject *const *args, Py_ssize_t nargs);

                </code></pre>


                This can be combined with the <code>METH_KEYWORDS</code> flag:

                <code>METH_FASTCALL | METH_KEYWORDS</code>

                <pre><code>
                PyObject *func(PyObject *self,
                    PyObject *const *args, Py_ssize_t nargs,
                    PyObject *kwnames /* tuple of keyword names or NULL */);

                </code></pre>



                <h5>Binding Modifiers</h5>

                The <code>ml_flags</code> field can also include binding modifiers that affect how the method is bound to the Python object. These modifiers are used to control how the method behaves when called from Python. Some common binding modifiers include:

                <ul>
                    <li><code>METH_METHOD</code>: Adds the defining class parameter before args.</li>
                    <li><code>METH_STATIC</code>: The method is a static method and does not receive the instance (self) as the first argument.</li>
                    <li><code>METH_CLASS</code>: The method is a class method and receives the class (cls) as the first argument instead of the instance.</li>
                    <li><code>METH_COEXIST</code>: This modifier allows the method to coexist with other methods that have the same name but different signatures.</li>
                </ul>


                <h5>Self</h5>

                <code>self</code> is used in regular Python, but how does it come into play in C-API? 
                <ul>
                    <li>For module functions, <code>self</code> is the module object</li>
                    <li>For type methods, <code>self</code> is the instance (or the type object for METH_CLASS)</li>
                </ul>

                

                <h5>Example</h5>

                

                /* 1) no args */
                static PyObject *m_nothing(PyObject *self, PyObject *Py_UNUSED(ignored)) {
                    Py_RETURN_NONE;
                }

                /* 2) one positional arg */
                static PyObject *m_square(PyObject *self, PyObject *arg) {
                    double x = PyFloat_AsDouble(arg);
                    if (x == -1.0 && PyErr_Occurred()) return NULL;
                    return PyFloat_FromDouble(x * x);
                }

                /* 3) varargs + kwargs */
                static PyObject *m_scale_add(PyObject *self, PyObject *args, PyObject *kwargs) {
                    static char *kwlist[] = {"x", "y", "scale", NULL};
                    double x, y, scale = 1.0;
                    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "dd|d:scale_add",
                                                    kwlist, &x, &y, &scale)) {
                        return NULL;
                    }
                    return PyFloat_FromDouble((x + y) * scale);
                }

                static PyMethodDef mod_methods[] = {
                    {"nothing", (PyCFunction)m_nothing, METH_NOARGS, "Return None."},
                    {"square",  (PyCFunction)m_square,  METH_O,      "Return x*x."},
                    {"scale_add",(PyCFunction)m_scale_add, METH_VARARGS|METH_KEYWORDS,
                                "scale_add(x, y, *, scale=1.0) -> float"},
                    {NULL, NULL, 0, NULL}
                };

                Always end the PyMethodDef with a null array (sentinel) as CPython overruns arrays.

                <h4>ml_doc</h4>

                The <code>ml_doc</code> field is a string that provides documentation for the method. It is used to generate the __doc__ attribute of the method in Python. If no documentation is provided, this field can be set to NULL.



                <h4>Type Methods</h4>

                You can also create type methods using PyMethodDef. Type methods are methods that are associated with a specific type (class) in Python. They are defined in a similar way to regular methods but are associated with a type object instead of a module.

                <pre><code>
                    static PyMethodDef MyTypeMethods[] = {
                        {"my_method", my_method, METH_VARARGS, "Description of my_method"},
                        {NULL, NULL, 0, NULL} // Sentinel
                    };

                    static PyTypeObject MyType = {
                        PyVarObject_HEAD_INIT(NULL, 0)
                        "mymodule.MyType", // tp_name
                        sizeof(MyTypeObject), // tp_basicsize
                        0, // tp_itemsize
                        // Other type object fields...
                        .tp_methods = MyTypeMethods,
                    };
                </code></pre>

                <h5>Example</h5>
                /* instance method: length() -> float */
                static PyObject *Vec_length(PyObject *self, PyObject *Py_UNUSED(ignored));

                /* class method: from_polar(cls, r, theta) -> Vec */
                static PyObject *Vec_from_polar(PyObject *cls, PyObject *args);

                /* static method: dot(a, b) -> float */
                static PyObject *Vec_dot(PyObject *Py_UNUSED(null), PyObject *args);

                static PyMethodDef Vec_methods[] = {
                    {"length",      (PyCFunction)Vec_length,     METH_NOARGS, "Euclidean length"},
                    {"from_polar",  (PyCFunction)Vec_from_polar, METH_VARARGS | METH_CLASS,
                                    "Construct from polar coordinates"},
                    {"dot",         (PyCFunction)Vec_dot,        METH_VARARGS | METH_STATIC,
                                    "Dot product of two Vecs"},
                    {NULL, NULL, 0, NULL}
                };


      
                </div>



             




        </div>

</body>
</html>