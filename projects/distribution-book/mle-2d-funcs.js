// script.js


function togglePlotView() {
    const view = document.getElementById('plotType').value;
    // Show contour options only when 'contour' view is selected
    document.getElementById('contourOptions').style.display = (view === 'contour') ? 'block' : 'none';

    // plotCostFunction();
}

document.addEventListener('DOMContentLoaded', () => {
    const plotButton = document.getElementById('plotButton');
    const distributionSelect = document.getElementById('distribution');
    const parameterRangesDiv = document.getElementById('parameterRanges');
    const logScaleCheckbox = document.getElementById('logScale');
    const colorSchemeSelect = document.getElementById('colorScheme');
    const autogenerateButton = document.getElementById('autogenerateButton');
    const dataInputField = document.getElementById('data');
    const plotTypeSelect = document.getElementById('plotType');

    // Update parameter range inputs when distribution changes
    distributionSelect.addEventListener('change', updateParameterInputs);

    plotButton.addEventListener('click', plotLikelihood);
    autogenerateButton.addEventListener('click', autogenerateData);

    // Initialize parameter inputs
    updateParameterInputs();

    function updateParameterInputs() {
        const distribution = distributionSelect.value;
        parameterRangesDiv.innerHTML = ''; // Clear previous inputs

        if (distribution === 'normal') {
            parameterRangesDiv.innerHTML = `
                <label>μ (mean) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="muMin" placeholder="Min μ" value="0">
                    <input type="number" id="muMax" placeholder="Max μ" value="10">
                </div>
                <label>σ (standard deviation) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="sigmaMin" placeholder="Min σ" value="1" inputmode="decimal">
                    <input type="number" id="sigmaMax" placeholder="Max σ" value="5" inputmode="decimal">
                </div>
            `;
        } else if (distribution === 'gamma' || distribution === 'invGamma') {
            parameterRangesDiv.innerHTML = `
                <label>α (shape parameter) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="alphaMin" placeholder="Min α" value="2" inputmode="decimal">
                    <input type="number" id="alphaMax" placeholder="Max α" value="5" inputmode="decimal">
                </div>
                <label>β (rate parameter) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="betaMin" placeholder="Min β" value="1" inputmode="decimal">
                    <input type="number" id="betaMax" placeholder="Max β" value="3" inputmode="decimal">
                </div>
            `;
        } else if (distribution === 'beta') {
            parameterRangesDiv.innerHTML = `
                <label>α (alpha parameter) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="alphaMin" placeholder="Min α" value="2" inputmode="decimal">
                    <input type="number" id="alphaMax" placeholder="Max α" value="5" inputmode="decimal">
                </div>
                <label>β (beta parameter) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="betaMin" placeholder="Min β" value="2" inputmode="decimal">
                    <input type="number" id="betaMax" placeholder="Max β" value="5" inputmode="decimal">
                </div>
            `;
        } else if (distribution === 'laplace') {
            parameterRangesDiv.innerHTML = `
                <label>μ (location parameter) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="muMin" placeholder="Min μ" value="0">
                    <input type="number" id="muMax" placeholder="Max μ" value="10">
                </div>
                <label>b (scale parameter) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="bMin" placeholder="Min b" value="1" inputmode="decimal">
                    <input type="number" id="bMax" placeholder="Max b" value="5" inputmode="decimal">
                </div>
            `;
        } else if (distribution === 'cauchy') {
            parameterRangesDiv.innerHTML = `
                <label>x₀ (location parameter) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="x0Min" placeholder="Min x₀" value="0">
                    <input type="number" id="x0Max" placeholder="Max x₀" value="10">
                </div>
                <label>γ (scale parameter) Range:</label>
                <div class="parameter-range">
                    <input type="number" id="gammaMin" placeholder="Min γ" value="1">
                    <input type="number" id="gammaMax" placeholder="Max γ" value="5">
                </div>
            `;
        }
    }

    function plotLikelihood() {
        const distribution = distributionSelect.value;
        const plotType = plotTypeSelect.value; 
        // Validate parameters before proceeding
        if (!validateParameters(distribution)) {
            return;
        }
    
        const dataInput = dataInputField.value;
        const data = parseData(dataInput);
    
        if (data.length === 0) {
            alert('Please enter valid data points.');
            return;
        }
    
        // Show loading indicator
        showLoadingIndicator();
    
        const useLogScale = logScaleCheckbox.checked;
        const colorScheme = colorSchemeSelect.value;
        const granularityInput = parseInt(document.getElementById('granularity').value);
        const granularity = isNaN(granularityInput) || granularityInput < 50 ? 100 : granularityInput;
    
        try {
            if (distribution === 'normal') {
                plotNormalLikelihood(data, useLogScale, colorScheme, granularity,plotType);
            } else if (distribution === 'gamma') {
                plotGammaLikelihood(data, useLogScale, colorScheme, granularity,plotType);
            } else if (distribution === 'beta') {
                plotBetaLikelihood(data, useLogScale, colorScheme, granularity,plotType);
            } else if (distribution === 'laplace') {
                plotLaplaceLikelihood(data, useLogScale, colorScheme, granularity,plotType);
            } else if (distribution === 'cauchy') {
                plotCauchyLikelihood(data, useLogScale, colorScheme, granularity,plotType);
            } else if (distribution === 'invGamma') {
                plotInvGammaLikelihood(data, useLogScale, colorScheme, granularity,plotType);
            } else {
                alert('Selected distribution is not supported.');
            }
        } catch (error) {
            alert('Error plotting likelihood: ' + error.message);
        } finally {
            // Hide loading indicator
            hideLoadingIndicator();
        }
    }
    // Function to calculate and display summary statistics
function displaySummaryStatistics(data) {
    if (data.length === 0) return;

    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
    const variance = data.reduce((sum, val) => sum + (val - mean) ** 2, 0) / data.length;
    const stdDev = Math.sqrt(variance);

    const summaryDiv = document.getElementById('summary');
    if (!summaryDiv) {
        const newSummaryDiv = document.createElement('div');
        newSummaryDiv.id = 'summary';
        newSummaryDiv.style.marginTop = '20px';
        document.getElementById('controls').appendChild(newSummaryDiv);
    }

    document.getElementById('summary').innerHTML = `
        <h3>Data Summary:</h3>
        <p>Mean: ${mean.toFixed(4)}</p>
        <p>Variance: ${variance.toFixed(4)}</p>
        <p>Standard Deviation: ${stdDev.toFixed(4)}</p>
    `;
}


    function parseData(input) {
        return input.split(',')
                    .map(s => parseFloat(s.trim()))
                    .filter(x => !isNaN(x));
    }

    function autogenerateData() {
        const distribution = distributionSelect.value;
    
        // Validate parameters before proceeding
        if (!validateParameters(distribution)) {
            return;
        }
    
        // Read the number of data points from the input field
        const numDataPointsInput = parseInt(document.getElementById('numDataPoints').value);
        const numDataPoints = isNaN(numDataPointsInput) || numDataPointsInput < 1 ? 100 : numDataPointsInput;
        let generatedData = [];
    
        // Get current parameter values or use defaults
        const params = getCurrentParameters(distribution);
    
        try {
            // Show loading indicator
            showLoadingIndicator();
    
            switch (distribution) {
                case 'normal':
                    generatedData = generateNormalData(numDataPoints, params.mu, params.sigma);
                    break;
                case 'gamma':
                    generatedData = generateGammaData(numDataPoints, params.alpha, params.beta);
                    break;
                case 'beta':
                    generatedData = generateBetaData(numDataPoints, params.alpha, params.beta);
                    break;
                case 'laplace':
                    generatedData = generateLaplaceData(numDataPoints, params.mu, params.b);
                    break;
                case 'cauchy':
                    generatedData = generateCauchyData(numDataPoints, params.x0, params.gamma);
                    break;
                case 'invGamma':
                    generatedData = generateInvGammaData(numDataPoints, params.alpha, params.beta);
                    break;
                default:
                    alert('Data generation for the selected distribution is not implemented.');
                    hideLoadingIndicator();
                    return;
            }
    
            // Populate the data input field
            dataInputField.value = generatedData.join(', ');
    
            // Display summary statistics (if implemented)
            displaySummaryStatistics(generatedData);
        } catch (error) {
            alert('Error generating data: ' + error.message);
        } finally {
            // Hide loading indicator
            hideLoadingIndicator();
        }
    }
    

    function getCurrentParameters(distribution) {
        const params = {};
        switch (distribution) {
            case 'normal':
                const muMin = parseFloat(document.getElementById('muMin').value) || 0;
                const muMax = parseFloat(document.getElementById('muMax').value) || 10;
                params.mu = randomInRange(muMin, muMax);
    
                const sigmaMin = parseFloat(document.getElementById('sigmaMin').value) || 1;
                const sigmaMax = parseFloat(document.getElementById('sigmaMax').value) || 5;
                params.sigma = randomInRange(sigmaMin, sigmaMax);
                break;
    
            case 'gamma':
            case 'invGamma':
                const alphaMin = parseFloat(document.getElementById('alphaMin').value) || 2;
                const alphaMax = parseFloat(document.getElementById('alphaMax').value) || 5;
                params.alpha = randomInRange(alphaMin, alphaMax);
    
                const betaMin = parseFloat(document.getElementById('betaMin').value) || 1;
                const betaMax = parseFloat(document.getElementById('betaMax').value) || 3;
                params.beta = randomInRange(betaMin, betaMax);
                break;
    
            case 'beta':
                const alphaMinBeta = parseFloat(document.getElementById('alphaMin').value) || 2;
                const alphaMaxBeta = parseFloat(document.getElementById('alphaMax').value) || 5;
                params.alpha = randomInRange(alphaMinBeta, alphaMaxBeta);
    
                const betaMinBeta = parseFloat(document.getElementById('betaMin').value) || 2;
                const betaMaxBeta = parseFloat(document.getElementById('betaMax').value) || 5;
                params.beta = randomInRange(betaMinBeta, betaMaxBeta);
                break;
    
            case 'laplace':
                const muMinLaplace = parseFloat(document.getElementById('muMin').value) || 0;
                const muMaxLaplace = parseFloat(document.getElementById('muMax').value) || 10;
                params.mu = randomInRange(muMinLaplace, muMaxLaplace);
    
                const bMin = parseFloat(document.getElementById('bMin').value) || 1;
                const bMax = parseFloat(document.getElementById('bMax').value) || 5;
                params.b = randomInRange(bMin, bMax);
                break;
    
            case 'cauchy':
                const x0Min = parseFloat(document.getElementById('x0Min').value) || 0;
                const x0Max = parseFloat(document.getElementById('x0Max').value) || 10;
                params.x0 = randomInRange(x0Min, x0Max);
    
                const gammaMin = parseFloat(document.getElementById('gammaMin').value) || 1;
                const gammaMax = parseFloat(document.getElementById('gammaMax').value) || 5;
                params.gamma = randomInRange(gammaMin, gammaMax);
                break;
    
            default:
                throw new Error('Unsupported distribution for data generation.');
        }
        return params;
    }
    

    // Sampling Functions
    function generateNormalData(n, mu, sigma) {
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push(mu + sigma * boxMullerTransform());
        }
        return data;
    }

    function boxMullerTransform() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random(); // Converting [0,1) to (0,1)
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function generateGammaData(n, alpha, beta) {
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push(gammaRandom(alpha, beta));
        }
        return data;
    }

    // Marsaglia and Tsang's method for Gamma distribution
    function gammaRandom(alpha, beta) {
        if (alpha < 1) {
            const u = Math.random();
            return gammaRandom(alpha + 1, beta) * Math.pow(u, 1 / alpha);
        }
        const d = alpha - 1 / 3;
        const c = 1 / Math.sqrt(9 * d);
        while (true) {
            let x = boxMullerTransform() || 0.0001; // Avoid zero
            let v = 1 + c * x;
            if (v <= 0) continue;
            v = v ** 3;
            const u = Math.random();
            if (u < 1 - 0.0331 * (x ** 4)) return d * v / beta;
            if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v / beta;
        }
    }

    function generateBetaData(n, alpha, betaParam) {
        const data = [];
        for (let i = 0; i < n; i++) {
            const x = gammaRandom(alpha, 1);
            const y = gammaRandom(betaParam, 1);
            data.push(x / (x + y));
        }
        return data;
    }

    function generateLaplaceData(n, mu, b) {
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push(laplaceRandom(mu, b));
        }
        return data;
    }

    function laplaceRandom(mu, b) {
        const u = Math.random() - 0.5;
        return mu - b * Math.sign(u) * Math.log(1 - 2 * Math.abs(u));
    }

    function generateCauchyData(n, x0, gamma) {
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push(cauchyRandom(x0, gamma));
        }
        return data;
    }

    function cauchyRandom(x0, gamma) {
        const u = Math.random() - 0.5;
        return x0 + gamma * Math.tan(Math.PI * u);
    }

    function generateInvGammaData(n, alpha, beta) {
        const data = [];
        for (let i = 0; i < n; i++) {
            const gammaSample = gammaRandom(alpha, 1); // Inverse Gamma with beta
            data.push(beta / gammaSample);
        }
        return data;
    }

    // Plotting functions for each distribution (unchanged)
    function plotNormalLikelihood(data, useLogScale, colorScheme, granularity,plotType) {
        // Get parameter ranges from user inputs
        const muMin = parseFloat(document.getElementById('muMin').value) || (Math.min(...data) - 2);
        const muMax = parseFloat(document.getElementById('muMax').value) || (Math.max(...data) + 2);
        const sigmaMin = parseFloat(document.getElementById('sigmaMin').value) || 0.1;
        const sigmaMax = parseFloat(document.getElementById('sigmaMax').value) || 5;

        const muRange = linspace(muMin, muMax, granularity);
        const sigmaRange = linspace(sigmaMin, sigmaMax, granularity);

        const z = [];
        for (let i = 0; i < sigmaRange.length; i++) {
            z[i] = [];
            for (let j = 0; j < muRange.length; j++) {
                const mu = muRange[j];
                const sigma = sigmaRange[i];
                const logLikelihood = data.reduce((sum, x) => sum + Math.log(normalPDF(x, mu, sigma)), 0);
                z[i][j] = logLikelihood;
            }
        }

        plotHeatmap(muRange, sigmaRange, z, 'μ (mean)', 'σ (standard deviation)', 'Log-Likelihood Heatmap for Normal Distribution', useLogScale, colorScheme,plotType);
    }

    function plotGammaLikelihood(data, useLogScale, colorScheme, granularity,plotType) {
        // Get parameter ranges from user inputs
        const alphaMin = parseFloat(document.getElementById('alphaMin').value) || 0.1;
        const alphaMax = parseFloat(document.getElementById('alphaMax').value) || 10;
        const betaMin = parseFloat(document.getElementById('betaMin').value) || 0.1;
        const betaMax = parseFloat(document.getElementById('betaMax').value) || 10;

        const alphaRange = linspace(alphaMin, alphaMax, granularity);
        const betaRange = linspace(betaMin, betaMax, granularity);

        const z = [];
        for (let i = 0; i < betaRange.length; i++) {
            z[i] = [];
            for (let j = 0; j < alphaRange.length; j++) {
                const alpha = alphaRange[j];
                const beta = betaRange[i];
                const logLikelihood = data.reduce((sum, x) => sum + Math.log(gammaPDF(x, alpha, beta)), 0);
                z[i][j] = logLikelihood;
            }
        }

        plotHeatmap(alphaRange, betaRange, z, 'α (shape parameter)', 'β (rate parameter)', 'Log-Likelihood Heatmap for Gamma Distribution', useLogScale, colorScheme,plotType);
    }

    function plotBetaLikelihood(data, useLogScale, colorScheme, granularity,plotType) {
        // Get parameter ranges from user inputs
        const alphaMin = parseFloat(document.getElementById('alphaMin').value) || 0.1;
        const alphaMax = parseFloat(document.getElementById('alphaMax').value) || 10;
        const betaMin = parseFloat(document.getElementById('betaMin').value) || 0.1;
        const betaMax = parseFloat(document.getElementById('betaMax').value) || 10;

        const alphaRange = linspace(alphaMin, alphaMax, granularity);
        const betaRange = linspace(betaMin, betaMax, granularity);

        const z = [];
        for (let i = 0; i < betaRange.length; i++) {
            z[i] = [];
            for (let j = 0; j < alphaRange.length; j++) {
                const alpha = alphaRange[j];
                const beta = betaRange[i];
                const logLikelihood = data.reduce((sum, x) => sum + Math.log(betaPDF(x, alpha, beta)), 0);
                z[i][j] = logLikelihood;
            }
        }

        plotHeatmap(alphaRange, betaRange, z, 'α (alpha parameter)', 'β (beta parameter)', 'Log-Likelihood Heatmap for Beta Distribution', useLogScale, colorScheme,plotType);
    }

    function plotLaplaceLikelihood(data, useLogScale, colorScheme, granularity,plotType) {
        // Get parameter ranges from user inputs
        const muMin = parseFloat(document.getElementById('muMin').value) || (Math.min(...data) - 2);
        const muMax = parseFloat(document.getElementById('muMax').value) || (Math.max(...data) + 2);
        const bMin = parseFloat(document.getElementById('bMin').value) || 0.1;
        const bMax = parseFloat(document.getElementById('bMax').value) || 5;

        const muRange = linspace(muMin, muMax, granularity);
        const bRange = linspace(bMin, bMax, granularity);

        const z = [];
        for (let i = 0; i < bRange.length; i++) {
            z[i] = [];
            for (let j = 0; j < muRange.length; j++) {
                const mu = muRange[j];
                const b = bRange[i];
                const logLikelihood = data.reduce((sum, x) => sum + Math.log(laplacePDF(x, mu, b)), 0);
                z[i][j] = logLikelihood;
            }
        }

        plotHeatmap(muRange, bRange, z, 'μ (location parameter)', 'b (scale parameter)', 'Log-Likelihood Heatmap for Laplace Distribution', useLogScale, colorScheme,plotType);
    }

    function plotCauchyLikelihood(data, useLogScale, colorScheme, granularity,plotType) {
        // Get parameter ranges from user inputs
        const x0Min = parseFloat(document.getElementById('x0Min').value) || (Math.min(...data) - 2);
        const x0Max = parseFloat(document.getElementById('x0Max').value) || (Math.max(...data) + 2);
        const gammaMin = parseFloat(document.getElementById('gammaMin').value) || 0.1;
        const gammaMax = parseFloat(document.getElementById('gammaMax').value) || 5;

        const x0Range = linspace(x0Min, x0Max, granularity);
        const gammaRange = linspace(gammaMin, gammaMax, granularity);

        const z = [];
        for (let i = 0; i < gammaRange.length; i++) {
            z[i] = [];
            for (let j = 0; j < x0Range.length; j++) {
                const x0 = x0Range[j];
                const gamma = gammaRange[i];
                const logLikelihood = data.reduce((sum, x) => sum + Math.log(cauchyPDF(x, x0, gamma)), 0);
                z[i][j] = logLikelihood;
            }
        }

        plotHeatmap(x0Range, gammaRange, z, 'x₀ (location parameter)', 'γ (scale parameter)', 'Log-Likelihood Heatmap for Cauchy Distribution', useLogScale, colorScheme,plotType);
    }

    function plotInvGammaLikelihood(data, useLogScale, colorScheme, granularity,plotType) {
        // Get parameter ranges from user inputs
        const alphaMin = parseFloat(document.getElementById('alphaMin').value) || 0.1;
        const alphaMax = parseFloat(document.getElementById('alphaMax').value) || 10;
        const betaMin = parseFloat(document.getElementById('betaMin').value) || 0.1;
        const betaMax = parseFloat(document.getElementById('betaMax').value) || 10;

        const alphaRange = linspace(alphaMin, alphaMax, granularity);
        const betaRange = linspace(betaMin, betaMax, granularity);

        const z = [];
        for (let i = 0; i < betaRange.length; i++) {
            z[i] = [];
            for (let j = 0; j < alphaRange.length; j++) {
                const alpha = alphaRange[j];
                const beta = betaRange[i];
                const logLikelihood = data.reduce((sum, x) => sum + Math.log(invGammaPDF(x, alpha, beta)), 0);
                z[i][j] = logLikelihood;
            }
        }

        plotHeatmap(alphaRange, betaRange, z, 'α (shape parameter)', 'β (scale parameter)', 'Log-Likelihood Heatmap for Inverse Gamma Distribution', useLogScale, colorScheme,plotType);
    }

    // Helper function to plot heatmaps (unchanged)
    function plotHeatmap(xRange, yRange, zData, xLabel, yLabel, title, useLogScale, colorScheme,plotType) {
        // Normalize z-values
        const maxZ = Math.max(...zData.flat());
        const minZ = Math.min(...zData.flat());
        const normalizedZ = zData.map(row => row.map(z => z - maxZ));

        let zToPlot = normalizedZ;

        if (useLogScale) {
            // Apply logarithmic scaling to the negative z-values
            zToPlot = normalizedZ.map(row => row.map(z => z < 0 ? Math.log(-z) : null));
        }

         dataPlot = [{
            x: xRange,
            y: yRange,
            z: zToPlot,
            type: plotType, // Use the selected plot type
            colorscale: colorScheme,
    
            zsmooth: false,
            colorbar: { title: useLogScale ? 'Log(-ΔLL)' : 'ΔLL' },
            reversescale: false
        }];


        let layout = {
            title: title
        };
        if (plotType === 'surface') {
            layout.scene = {
                xaxis: { title: xLabel },
                yaxis: { title: yLabel },
                zaxis: { title: useLogScale ? 'Log(-ΔLL)' : 'ΔLL' }
            };
             dataPlot[0].showscale = false; // Hide colorbar if not needed
        } else if (plotType == 'contour'){
            const numContours = parseInt(document.getElementById('numContours').value);
       
            dataPlot[0].ncontours = numContours;
        }
        
        else {
            layout.xaxis = { title: xLabel };
            layout.yaxis = { title: yLabel };
        }

        Plotly.newPlot('plot', dataPlot, layout);
    }

    // Probability density functions (unchanged)
    function normalPDF(x, mu, sigma) {
        const coeff = 1 / (sigma * Math.sqrt(2 * Math.PI));
        const exponent = -((x - mu) ** 2) / (2 * sigma ** 2);
        return coeff * Math.exp(exponent);
    }

    function gammaPDF(x, alpha, beta) {
        if (x <= 0) return 1e-100; // Avoid log(0)
        const coeff = (beta ** alpha) / gammaFunc(alpha);
        return coeff * x ** (alpha - 1) * Math.exp(-beta * x);
    }

    function betaPDF(x, alpha, beta) {
        if (x <= 0 || x >= 1) return 1e-100; // Beta distribution is defined on (0,1)
        const coeff = gammaFunc(alpha + beta) / (gammaFunc(alpha) * gammaFunc(beta));
        return coeff * x ** (alpha - 1) * (1 - x) ** (beta - 1);
    }

    function laplacePDF(x, mu, b) {
        if (b <= 0) return 1e-100; // Scale parameter must be positive
        return (1 / (2 * b)) * Math.exp(-Math.abs(x - mu) / b);
    }

    function cauchyPDF(x, x0, gamma) {
        if (gamma <= 0) return 1e-100; // Scale parameter must be positive
        return (1 / (Math.PI * gamma)) * (gamma ** 2 / ((x - x0) ** 2 + gamma ** 2));
    }

    function invGammaPDF(x, alpha, beta) {
        if (x <= 0) return 1e-100; // Inverse Gamma is defined for x > 0
        const coeff = (beta ** alpha) / gammaFunc(alpha);
        return coeff * x ** (-alpha - 1) * Math.exp(-beta / x);
    }

    // Helper function to generate a random number within a specified range
function randomInRange(min, max) {
    return min + Math.random() * (max - min);
}

// Function to validate parameter ranges
function validateParameters(distribution) {
    const errors = [];
    switch (distribution) {
        case 'normal':
            const sigmaMin = parseFloat(document.getElementById('sigmaMin').value);
            const sigmaMax = parseFloat(document.getElementById('sigmaMax').value);
            if (sigmaMin <= 0) errors.push('Minimum σ must be greater than 0.');
            if (sigmaMax <= 0) errors.push('Maximum σ must be greater than 0.');
            if (sigmaMax < sigmaMin) errors.push('Maximum σ must be greater than or equal to Minimum σ.');
            break;
        case 'gamma':
        case 'invGamma':
            const alphaMin = parseFloat(document.getElementById('alphaMin').value);
            const alphaMax = parseFloat(document.getElementById('alphaMax').value);
            const betaMin = parseFloat(document.getElementById('betaMin').value);
            const betaMax = parseFloat(document.getElementById('betaMax').value);
            if (alphaMin <= 0) errors.push('Minimum α must be greater than 0.');
            if (alphaMax <= 0) errors.push('Maximum α must be greater than 0.');
            if (alphaMax < alphaMin) errors.push('Maximum α must be greater than or equal to Minimum α.');
            if (betaMin <= 0) errors.push('Minimum β must be greater than 0.');
            if (betaMax <= 0) errors.push('Maximum β must be greater than 0.');
            if (betaMax < betaMin) errors.push('Maximum β must be greater than or equal to Minimum β.');
            break;
        case 'beta':
            const alphaMinBeta = parseFloat(document.getElementById('alphaMin').value);
            const alphaMaxBeta = parseFloat(document.getElementById('alphaMax').value);
            const betaMinBeta = parseFloat(document.getElementById('betaMin').value);
            const betaMaxBeta = parseFloat(document.getElementById('betaMax').value);
            if (alphaMinBeta <= 0) errors.push('Minimum α must be greater than 0.');
            if (alphaMaxBeta <= 0) errors.push('Maximum α must be greater than 0.');
            if (alphaMaxBeta < alphaMinBeta) errors.push('Maximum α must be greater than or equal to Minimum α.');
            if (betaMinBeta <= 0) errors.push('Minimum β must be greater than 0.');
            if (betaMaxBeta <= 0) errors.push('Maximum β must be greater than 0.');
            if (betaMaxBeta < betaMinBeta) errors.push('Maximum β must be greater than or equal to Minimum β.');
            break;
        case 'laplace':
            const bMin = parseFloat(document.getElementById('bMin').value);
            const bMax = parseFloat(document.getElementById('bMax').value);
            if (bMin <= 0) errors.push('Minimum b must be greater than 0.');
            if (bMax <= 0) errors.push('Maximum b must be greater than 0.');
            if (bMax < bMin) errors.push('Maximum b must be greater than or equal to Minimum b.');
            break;
        case 'cauchy':
            const gammaMin = parseFloat(document.getElementById('gammaMin').value);
            const gammaMax = parseFloat(document.getElementById('gammaMax').value);
            if (gammaMin <= 0) errors.push('Minimum γ must be greater than 0.');
            if (gammaMax <= 0) errors.push('Maximum γ must be greater than 0.');
            if (gammaMax < gammaMin) errors.push('Maximum γ must be greater than or equal to Minimum γ.');
            break;
        default:
            errors.push('Unsupported distribution for parameter validation.');
    }

    if (errors.length > 0) {
        alert('Parameter Validation Errors:\n' + errors.join('\n'));
        return false;
    }
    return true;
}

// Function to show the loading indicator and disable buttons
function showLoadingIndicator() {
    const plotDiv = document.getElementById('plot');
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'loading';
    loadingDiv.innerHTML = '<div class="spinner"></div><p>Loading...</p>';
    plotDiv.appendChild(loadingDiv);

    // Disable buttons to prevent multiple clicks
    document.getElementById('plotButton').disabled = true;
    document.getElementById('autogenerateButton').disabled = true;
}

// Function to hide the loading indicator and enable buttons
function hideLoadingIndicator() {
    const loadingDiv = document.getElementById('loading');
    if (loadingDiv) {
        loadingDiv.remove();
    }

    // Enable buttons after loading
    document.getElementById('plotButton').disabled = false;
    document.getElementById('autogenerateButton').disabled = false;
}



    // Gamma function approximation (Lanczos approximation)
    function gammaFunc(z) {
        const g = 7;
        const p = [
            0.99999999999980993, 676.5203681218851, -1259.1392167224028,
            771.32342877765313, -176.61502916214059, 12.507343278686905,
            -0.13857109526572012, 9.9843695780195716e-6,
            1.5056327351493116e-7
        ];
        if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gammaFunc(1 - z));
        z -= 1;
        let x = p[0];
        for (let i = 1; i < g + 2; i++) {
            x += p[i] / (z + i);
        }
        const t = z + g + 0.5;
        return Math.sqrt(2 * Math.PI) * t ** (z + 0.5) * Math.exp(-t) * x;
    }

    function linspace(start, end, num) {
        const arr = [];
        const step = (end - start) / (num - 1);
        for (let i = 0; i < num; i++) {
            arr.push(start + step * i);
        }
        return arr;
    }
});
document.addEventListener('DOMContentLoaded', () => {

    
    // Function to handle file upload and parse data points
    document.getElementById('plotType').addEventListener('change', togglePlotView());
  
}

    );