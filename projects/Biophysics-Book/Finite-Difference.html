<!DOCTYPE html>
<html lang="en-US">
    <head>

        <meta charset="UTF-8">
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2C44LTKBE1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2C44LTKBE1');
</script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
            <title>Finite Difference Method</title>
    
        <!-- Meta tags -->
        
        <meta name="keywords" content="Finite Difference Method, PDE, Euler">
        <meta name="author" content="John Della Rosa" >
        <meta name="description" content="Finite Difference is a numerical way of solving Partial Differential Equations (PDEs).">
        
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
        <link rel="apple-touch-icon" sizes="180x180" href="https://johndellarosa.github.io/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://johndellarosa.github.io/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://johndellarosa.github.io/favicon-16x16.png">
        <link rel="manifest" href="https://johndellarosa.github.io/site.webmanifest">
            
        <link rel="stylesheet" href="https://johndellarosa.github.io/style.css"> 
<!-- 
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
      

        <script src="../../math.js" type="text/javascript"></script> -->

    </head>
    <body>
        <div class="navbar">
            <b style="margin-right:10px">John Della Rosa</b>| 
            <a href="https://johndellarosa.github.io/index.html">Home</a>|
            <a href="https://johndellarosa.github.io/resume.html">Resume</a>
            <!-- <a href="./index.html#education">Education</a>
            <a href="./index.html#experience">Experience</a>
            <a href="./index.html#skills">Skills</a> -->
            |
            <a href="https://johndellarosa.github.io/biography.html">About</a>|
            <a href="https://johndellarosa.github.io/projects.html">Projects</a>|
            <a href="https://johndellarosa.github.io/Miscellaneous.html">Misc</a>|
            <a href="https://www.linkedin.com/in/johndellarosa/" target="_blank">Linkedin</a>|
            <a href="https://github.com/johndellarosa" target="_blank">Github</a>|
            <a href="https://play.google.com/store/apps/developer?id=JohnDellaRosa" target="_blank">Google Play</a>|
            <a href="https://apps.apple.com/us/developer/john-della-rosa/id1684177615" target="_blank">Apple Store</a>
        
        </div>
        <h2><a href= "Table-of-Contents.html">Biophysical Chemistry Textbook (Work in Progress)</a></h2>

<h3>by John Della Rosa</h3>
        <div id="text-contents" style="width:90%; margin:auto">
            <div id="Finite Difference">
                <h1>Finite Difference Method</h1>
                <h2>Introduction</h2>
                In practice, many PDEs do not have closed-form solutions. Finite difference methods (FDM) are numerical techniques used to approximate the solutions of partial differential equations (PDEs). By discretizing the domain into a finite number of grid points, FDM translates continuous PDEs into a system of algebraic equations. 
                


                <h2>Simpler Models</h2>
                <h3>Euler Method</h3>

                The Euler method is a simple way for solving an ordinary differential equation (ODE). 
                If we are given the differential equation, we attempt to numerically solve it by taking small steps. 

                $$y_{n+1}=y_n+hf(t_n,y_n)$$

                <h4>Taylor Expansion</h4>

                For a function, f, we can write the value of the function at a nearby point through a Taylor series. 

                $$y(t_0+h)=y(t_0)=hy'(t_0)+\frac{1}{2}h^2y''(t_0)+\dots$$

                Using this formula, we can attempt to determine the path followed given initial conditions by repeatedly taking small steps of size h. 

                <h4>Example</h4>

                We shall consider the simple differential equation

                $$y'=2t$$

                with initial condition

                $$y(0)=0$$

                <img src="Euler-Method-ODE.png" alt="Euler Method for ODE" style="margin:auto; display: block;  width:clamp(300px,40vw, 800px)"/>
                <button type="button" class="collapsible">Python Code</button>
                <div class="content">
                <code style="margin: auto; width: 50%;"><pre>
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme(style="whitegrid")
def euler_method(f, y0, t):
    y = np.zeros(t.shape)
    y[0] = y0
    dt = t[1] - t[0]
    for n in range(0, len(t)-1):
        y[n+1] = y[n] + dt * f(t[n], y[n])
    return y

# Differential equation
f = lambda t, y: 2 * t
exact_solution = lambda t: t ** 2

t = np.linspace(0, 2, 100)  # Time values
y_exact = exact_solution(t)
y_euler = euler_method(f, 0, t)

# Plot
plt.figure(figsize=(8,6))
plt.plot(t, y_exact, label="Exact Solution: $t^{2}$", color='tab:blue')
colors = ['tab:red','tab:orange','tab:green']
for i,n in enumerate([5,11,101]):
    t = np.linspace(0, 2, n)  # Time values
    y_euler = euler_method(f, 0, t)
    plt.plot(t, y_euler, label=f"Euler's Method h={2/(n-1)}", linestyle='--', color=colors[i])
#plt.plot(t, y_euler, label="Euler's Method", linestyle='--', color='red')
plt.title("Euler's Method for Solving ODEs")
plt.xlabel('t')
plt.ylabel('y(t)')
plt.legend()
plt.grid(True)
plt.show()
                    
                    
                             
</pre>
                </code></div>

                <h4>More complicated example</h4>
                We can also include values of the function itself in the differential equation. 

                $$y'(t)=-t\times y(t)$$
                with initial condition

                $$y(0)=1$$
                <img src="Euler-Gaussian.png" alt="Euler method for Exponential" style="margin:auto; display: block;  width:clamp(300px,40vw, 800px)"/>
                <button type="button" class="collapsible">Python Code</button>
                <div class="content">
                <code style="margin: auto; width: 50%;"><pre>
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
#sns.set_theme(style="whitegrid")
def euler_method(f, y0, t):
    y = np.zeros(t.shape)
    y[0] = y0
    dt = t[1] - t[0]
    for n in range(0, len(t)-1):
        y[n+1] = y[n] + dt * f(t[n], y[n])
    return y

# Differential equation
f = lambda t, y: -(1*t)*y
exact_solution = lambda t: np.exp(-0.5*t**2)

t = np.linspace(0, 3, 100)  # Time values
y_exact = exact_solution(t)
y_euler = euler_method(f, 1, t)

# Plot
plt.figure(figsize=(8,6))
plt.plot(t, y_exact, label=r"Exact Solution: $\frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}$", color='tab:blue')
colors = ['tab:red','tab:orange','tab:green']
for i,n in enumerate([5,11,101]):
    t = np.linspace(0, 3, n)  # Time values
    y_euler = euler_method(f, 1, t)
    plt.plot(t, y_euler, label=f"Euler's Method h={2/(n-1)}", linestyle='--', color=colors[i])
    
#plt.plot(t, y_euler, label="Euler's Method", linestyle='--', color='red')
plt.title("Euler's Method for Solving ODEs")
plt.xlabel('t')
plt.ylabel('y(t)')
plt.ylim(-.25,1.25)
plt.legend()
plt.grid(True)
plt.show()                   
</pre>
                </code></div>

                <h2>Basics of Finite Difference</h2>
                <h3>Outline</h3>
                <ol>


                </ol>

                <h3>Difference Quotients</h3>
                <h4>Forward Difference</h4>
                $$\frac{f(x+h)-f(x)}{h}$$

                <h4>Backward Difference</h4>
                $$\frac{f(x)-f(x-h)}{h}$$

                <h4>Central Difference</h4>
                $$\frac{f(x+h)-f(x-h)}{2h}$$

                Taking the deriative with respect to other variables works the same. 
                When taking partial derivatives with respect to a variable, simply do not change the other variables like with normal partial differentiation. 

                <h4>Taking A Secant Line Closer (Central Difference)</h4>
                Smaller values of \(\Delta x\) make for better approximations, but stability conditions must be paid attention to.
                <img src="Secant-Lines.png" alt="Secant Line Estimations for Derivative" style="margin:auto; display: block;  width:clamp(400px,50vw, 800px)"/>
                <button type="button" class="collapsible">Python Code</button>
                <div class="content">
                <code style="margin: auto; width: 50%;"><pre>
import numpy as np
import matplotlib.pyplot as plt

def f(x):
    return np.exp(x)

def slope_of_secant(x1, x2):
    return (f(x2) - f(x1)) / (x2 - x1)

def extended_secant_line(x1, x2, X):
    slope = slope_of_secant(x1, x2)
    print(slope)
    y_intercept = f(x1) - slope * x1
    return slope * X + y_intercept

x = 1
h_values = [2,1, 0.5]

X = np.linspace(-3, 4, 400)
Y = f(X)

plt.figure(figsize=(8,6))
plt.plot(X, Y, label="y = $e^x$", color="black", linewidth=2)
colors = plt.colormaps['tab10'].colors
for i,h in enumerate(h_values):
    x2 = x + h
    x1 = x - h
    plt.plot(X, extended_secant_line(x1, x2, X), label=f"h = {h}; secant slope={slope_of_secant(x1, x2):.3f}", linestyle="--",color=colors[i])
    plt.scatter([x1, x2], [f(x1), f(x2)], color=colors[i])

plt.plot(X, np.exp(1)*X+f(1) - np.exp(1) * 1, label=f"Derivative; slope={np.exp(1):.3f}", linestyle="--",color=colors[3])  
plt.scatter([1], [f(1)], color=colors[3])
    
plt.title("Secant Line Estimations of the Derivative at x=1")
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.grid(True)
plt.xlim(-2, 4)
plt.ylim(-1, 25)
plt.show()
                    
                             
</pre>
                </code></div>
                
                <h4>Second Deriatives</h4>
                In order to get a second deriative of a function, one takes the derivative of the derivative. 
                The same logic applies for finite differences - take the finite difference of finite differences. 
                <br>
                Let us consider taking spacial derivative via forward differences for simplicity.
                
                $$f'(x)\approx \frac{f(x+\Delta x)-f(x)}{\Delta x}$$

                $$f''(x)\approx\frac{f'(x+h)-f'(x)}{h}$$

                Combining the two formulae, we get:

                $$f''(x)\approx\frac{\frac{f(x+2\Delta x)-f(x+\Delta x)}{\Delta x}-\frac{f(x+\Delta x)-f(x)}{\Delta x}}{\Delta x}$$
                $$f''(x)\approx\frac{f(x+2\Delta x)-2f(x+\Delta x)+f(x)}{(\Delta x)^2}$$

                One can also use the backward or central differences.

                <br><br>
                If one requires higher order derivatives, the same logic can be applied, iteratively taking finite differences. 
                
                <br><br>
                It is also possible to use finite differences for mixed partials. The central difference formula for mixed partials is relatively simple:

                $$\frac{\partial^2 f}{\partial x\partial y}=\frac{f(x+\Delta x,y+\Delta y)-f(x+\Delta x, y-\Delta y)-f(x-\Delta x, y+\Delta y)+f(x-\Delta x, y -\Delta y)}{4(\Delta x)(\Delta y)}$$

                <h4>Computational Considerations</h4>
                Mathematically, the formulas aren't that difficult. The issue is that it can be computationally expensive to compute all these function values. 

                <h3>Schemes</h3>

                <h4>Explicit</h4>

                The explicit scheme is perhaps the most intuitive. 
                You take all the partial deriatives at the current time point and use them to estimate the values at the next time point. 
                We can take the forward difference for time and central difference for space.

                <h5>Example - Heat Equation</h5>

                The heat equation is the basic example in the world of Partial Differential Equations. 
                It is simple and has an analytic solution. 
                It has dynamics given by 

                $$\frac{\partial u}{\partial t}=\alpha\frac{\partial^2 u}{\partial x^2}$$

                We will use the explicit scheme with with second order central difference for x and first order forward difference for time. 

                <br>
                Applying the operators, we get

                $$\frac{u_{i}^{n+1}-u_{i}^{n}}{\Delta t}=\alpha \frac{u_{i+1}^n-2u_{i}^n+u_{i-1}^n}{(\Delta x)^2}$$
                where i is the spatial index and n is the time index. 
                <br>
                We can rearrange this to solve for the unknown, which is the value at the next time point:

                $$u_{i}^{n+1}=u_{i}^{n}+\alpha\Delta t \frac{u_{i+1}^n-2u_{i}^n+u_{i-1}^n}{(\Delta x)^2}$$
                
                In the simulation below, the temperature is higher at the center and then follows the heat equation dynamics. 

                
                <img src="Heat-Equation-Explicit-Finite-Difference.gif" alt="Heat Equation Explicit Finite Difference" style="margin:auto; display: block;  width:clamp(300px,40vw, 800px)"/>
                <button type="button" class="collapsible">Python Code</button>
                <div class="content">
                <code style="margin: auto; width: 50%;"><pre>
# modified from https://levelup.gitconnected.com/solving-2d-heat-equation-numerically-using-python-3334004aa01a

bar_length = 10
max_iter_time = 10000
alpha = 5.0
n = 1000
delta_x = bar_length/n

# Calculated params
delta_t = (delta_x ** 2)/(4 * alpha)
gamma = (alpha * delta_t) / (delta_x ** 2)

# Initialize solution: the grid of u(k, i)
u = np.empty((max_iter_time, n))

sns.set_theme(style="whitegrid")


# Boundary conditions (fixed temperature)
u_left = 0.0
u_right = 0.0

# Set the initial condition
u.fill(0)

# initial heat pattern
initial_temp_peak = 250
u[:, n//2-100:n//2+100] = initial_temp_peak

def Explicit_Finite_Difference(u):
    for k in range(0, max_iter_time-1, 1):
        for i in range(1, n-1, 1):
                u[k + 1, i] = gamma * (u[k][i+1] + u[k][i-1] - 2*u[k][i]) + u[k][i]
    
    return u

def plotheatmap(u_k, k):
    # Clear the current plot figure
    plt.clf()
    plt.title(f"Finite Difference Heat Equation: Temperature at t = {k*delta_t:.3f} unit time")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.ylim([0,initial_temp_peak+50])
    # This is to plot u_k (u at time-step k)
    plt.plot([delta_x*i for i in range(n)],u_k)
    f = plt.fill_between([delta_x*i for i in range(n)],u_k,
                alpha=0.3,
                color='tab:blue',
                )


    return plt

u = Explicit_Finite_Difference(u)

def animate(k):
    k *= 100
    plotheatmap(u[k], k)

anim = animation.FuncAnimation(plt.figure(), animate, interval=1, frames=max_iter_time//100, repeat=False)
anim
anim.save("Heat-Equation-Finite-Difference.gif",fps=20) 
</pre>
                </code></div>

                <h4>Implicit</h4>
                In the implicit scheme, the spatial derivatives are taken at the <b>next</b> time point rather than the current one. 
                Since we need to use function values at the time we're trying to solve for, this requires a system of equations. 
                While this may seem like more trouble for no gain, we do not have to worry about stability, and thus have more freedom with choosing our \(\Delta x\) and \(\Delta t\). 

<h5>Heat Equation</h5>

$$\frac{u_{i}^{n+1}-u_{i}^{n}}{\Delta t}=\alpha \frac{u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1}}{(\Delta x)^2}$$
where i is the spatial index and n is the time index. 

<img src="Heat-Equation-Implicit-Finite-Difference.gif" alt="Heat Equation Implicit Finite Difference" style="margin:auto; display: block;  width:clamp(300px,40vw, 800px)"/>
<button type="button" class="collapsible">Python Code</button>
<div class="content">
<code style="margin: auto; width: 50%;"><pre>
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
sns.set_theme(style="whitegrid")
# Define the domain
L = 10.0   # length of the domain
Nx = 1000  # number of spatial points
dx = L / Nx
x = np.linspace(0, L, Nx)

# Diffusion coefficient
alpha = 1

# Time stepping parameters
dt = 0.001
Nt = 20000   # number of time steps
r = alpha * dt/dx**2

# Initial condition
u = np.zeros((Nt+1, Nx))
#u[0, :] = np.sin(np.pi * x)
initial_temp_peak = 250
u[0, Nx//2-Nx//10:Nx//2+Nx//10] = initial_temp_peak
# Set up the tridiagonal matrix
A = np.diag((1 + 2*alpha*r) * np.ones(Nx))
A += np.diag(-alpha*r * np.ones(Nx-1), k=1)
A += np.diag(-alpha*r * np.ones(Nx-1), k=-1)

fig, ax = plt.subplots()
#line, = ax.plot(x, u[0, :], '-r', label='Temperature')
line, = ax.plot([], '-r', label='Temperature')
ax.set_xlim(0, L)

ax.set_xlabel('x')
ax.set_ylabel('u')
ax.set_title('Animated Implicit Solution of the Heat Equation')

for t in range(Nt-1):
    u[t+1, :] = np.linalg.solve(A, u[t, :])
    u[t+1, 0] = 0
    u[t+1, -1] = 0

def update(num, u, line):
    plt.clf()
    num *= 10
    plt.ylim([0,initial_temp_peak+50])
    plt.title(f"Implicit Finite Difference Heat Equation: Temperature at t = {num*dt:.3f} unit time")
    plt.xlabel("x")
    plt.ylabel("Temperature")
    # Apply boundary conditions (here, Dirichlet with u=0 at both ends)

    plt.plot([dx*i for i in range(Nx)],u[num,:])
    f = plt.fill_between([dx*i for i in range(Nx)],u[num,:],
            alpha=0.3,
            color='tab:blue',
            )
    return line,

ani = FuncAnimation(fig, update, frames=Nt//10,interval=10, fargs=[u, line], blit=True)
plt.show()
ani.save("Heat-Equation-Finite-Difference.gif",fps=20)
</pre>
</code></div>

<h4>Crank-Nicolson Scheme</h4>
Crank-Nicolson is a more complicated type of Implicit, which is a combination of the traditional implicit method and the explicit method. One takes the spatial finite differences at both the starting and ending timepoints. 

$$\frac{u_{i}^{n+1}-u_{i}^{n}}{\Delta t}=\alpha \frac{(u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1})+(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n})}{2(\Delta x)^2}$$
where i is the spatial index and n is the time index. 


                <h2>Selected Applications</h2>
                    In the stochastic process chapter, we will cover a similar technique for another class of differential equations. 
                    The Euler-Maruyama method is similar to both Monte Carlo and Finite Difference. 
                </div>

                <div id="Exercises">
                    <h2>Exercises</h2>
                    <ol>
                        <li>The wave equation is given by </li>
                    
                    </ol>
    
    
                </div>
        </div>
        <script>
            var coll = document.getElementsByClassName("collapsible");
            var i;
    
            for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.display === "block") {
                content.style.display = "none";
                } else {
                content.style.display = "block";
                }
            });
            } 
            </script>
</body>
</html>